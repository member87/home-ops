---
apiVersion: v1
kind: ConfigMap
metadata:
  name: readmeabook-bootstrap-script
  namespace: readmeabook
data:
  bootstrap.mjs: |
    const requiredEnv = [
      "ABS_URL",
      "RMAB_URL",
      "PROWLARR_URL",
      "SABNZBD_URL",
      "ABS_ADMIN_USERNAME",
      "ABS_ADMIN_PASSWORD",
      "RMAB_ADMIN_USERNAME",
      "RMAB_ADMIN_PASSWORD",
      "PROWLARR_API_KEY",
      "SABNZBD_API_KEY",
      "RMAB_PUBLIC_URL",
      "DOWNLOAD_DIR",
      "MEDIA_DIR",
    ];

    for (const key of requiredEnv) {
      if (!process.env[key] || process.env[key].trim().length === 0) {
        throw new Error(`Missing required environment variable: ${key}`);
      }
    }

    const {
      ABS_URL,
      RMAB_URL,
      PROWLARR_URL,
      SABNZBD_URL,
      ABS_ADMIN_USERNAME,
      ABS_ADMIN_PASSWORD,
      RMAB_ADMIN_USERNAME,
      RMAB_ADMIN_PASSWORD,
      PROWLARR_API_KEY,
      SABNZBD_API_KEY,
      RMAB_PUBLIC_URL,
      DOWNLOAD_DIR,
      MEDIA_DIR,
      AUDIBLE_REGION = "us",
    } = process.env;

    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    async function request(url, options = {}) {
      const response = await fetch(url, options);
      const text = await response.text();
      let json = null;
      try {
        json = text ? JSON.parse(text) : null;
      } catch {
        json = null;
      }
      return { response, text, json };
    }

    async function waitFor(name, checkFn, attempts = 120, delayMs = 5000) {
      for (let i = 1; i <= attempts; i++) {
        try {
          const ok = await checkFn();
          if (ok) {
            console.log(`[bootstrap] ${name} is ready`);
            return;
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          console.log(`[bootstrap] waiting for ${name} (${i}/${attempts}): ${message}`);
        }
        await sleep(delayMs);
      }
      throw new Error(`Timed out waiting for ${name}`);
    }

    function ensureOk(result, context) {
      if (result.response.ok) return;
      const details = result.text || JSON.stringify(result.json);
      throw new Error(`${context} failed (${result.response.status}): ${details}`);
    }

    async function getEnabledProwlarrIndexers() {
      const result = await request(`${PROWLARR_URL}/api/v1/indexer`, {
        headers: {
          "X-Api-Key": PROWLARR_API_KEY,
        },
      });
      ensureOk(result, "Prowlarr indexer fetch");

      const all = Array.isArray(result.json) ? result.json : [];
      const enabled = all.filter((idx) => idx.enable);
      const usenet = enabled.filter((idx) => (idx.protocol || "").toLowerCase() === "usenet");
      const selected = usenet.length > 0 ? usenet : enabled;

      if (selected.length === 0) {
        throw new Error("No enabled Prowlarr indexers found");
      }

      return selected.map((idx, i) => ({
        id: idx.id,
        name: idx.name,
        protocol: idx.protocol,
        priority: Math.min(25, i + 1),
        seedingTimeMinutes: 0,
        removeAfterProcessing: false,
        rssEnabled: idx.capabilities?.supportsRss !== false,
      }));
    }

    async function ensureAbsInitialized() {
      const status = await request(`${ABS_URL}/status`);
      ensureOk(status, "Audiobookshelf status check");
      if (status.json?.isInit) {
        console.log("[bootstrap] Audiobookshelf already initialized");
        return;
      }

      console.log("[bootstrap] Initializing Audiobookshelf root user");
      const initResult = await request(`${ABS_URL}/init`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          newRoot: {
            username: ABS_ADMIN_USERNAME,
            password: ABS_ADMIN_PASSWORD,
          },
        }),
      });
      ensureOk(initResult, "Audiobookshelf initialization");
    }

    async function loginAbs() {
      const login = await request(`${ABS_URL}/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          username: ABS_ADMIN_USERNAME,
          password: ABS_ADMIN_PASSWORD,
        }),
      });
      ensureOk(login, "Audiobookshelf login");

      const accessToken = login.json?.user?.accessToken || login.json?.user?.token;
      if (!accessToken) {
        throw new Error("Audiobookshelf login succeeded but no access token was returned");
      }
      return accessToken;
    }

    async function ensureAbsLibrary(accessToken) {
      const headers = {
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json",
      };

      const existing = await request(`${ABS_URL}/api/libraries`, { headers });
      ensureOk(existing, "Audiobookshelf libraries fetch");

      let libraries = Array.isArray(existing.json?.libraries) ? existing.json.libraries : [];
      let library = libraries.find((lib) => lib.mediaType === "book" && lib.name === "Audiobooks");

      if (!library) {
        console.log("[bootstrap] Creating Audiobookshelf library");
        const create = await request(`${ABS_URL}/api/libraries`, {
          method: "POST",
          headers,
          body: JSON.stringify({
            name: "Audiobooks",
            folders: [{ path: MEDIA_DIR }],
            mediaType: "book",
            icon: "audiobookshelf",
            provider: "audible",
          }),
        });
        ensureOk(create, "Audiobookshelf library creation");

        const refresh = await request(`${ABS_URL}/api/libraries`, { headers });
        ensureOk(refresh, "Audiobookshelf libraries refresh");
        libraries = Array.isArray(refresh.json?.libraries) ? refresh.json.libraries : [];
        library = libraries.find((lib) => lib.mediaType === "book" && lib.name === "Audiobooks");
      }

      if (!library?.id) {
        throw new Error("Could not determine Audiobookshelf library id");
      }

      return library.id;
    }

    async function createAbsApiKey(accessToken) {
      const me = await request(`${ABS_URL}/api/me`, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      ensureOk(me, "Audiobookshelf current user fetch");

      const userId = me.json?.id;
      if (!userId) {
        throw new Error("Could not determine Audiobookshelf user id");
      }

      const key = await request(`${ABS_URL}/api/api-keys`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name: "readmeabook-bootstrap",
          userId,
          isActive: true,
        }),
      });
      ensureOk(key, "Audiobookshelf API key creation");

      const apiKey = key.json?.apiKey?.apiKey;
      if (!apiKey) {
        throw new Error("Audiobookshelf API key creation did not return a token");
      }
      return apiKey;
    }

    async function ensureRmabPaths() {
      const result = await request(`${RMAB_URL}/api/setup/test-paths`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          downloadDir: DOWNLOAD_DIR,
          mediaDir: MEDIA_DIR,
          audiobookPathTemplate: "{{author}}/{{title}}",
        }),
      });
      ensureOk(result, "ReadMeABook path validation");
      if (!result.json?.success) {
        throw new Error(`ReadMeABook path validation failed: ${JSON.stringify(result.json)}`);
      }
    }

    async function bootstrapRmab(absApiKey, absLibraryId, prowlarrIndexers) {
      const status = await request(`${RMAB_URL}/api/setup/status`);
      ensureOk(status, "ReadMeABook setup status check");
      if (status.json?.setupComplete) {
        console.log("[bootstrap] ReadMeABook setup already completed");
        return;
      }

      await ensureRmabPaths();

      const payload = {
        backendMode: "audiobookshelf",
        audibleRegion: AUDIBLE_REGION,
        admin: {
          username: RMAB_ADMIN_USERNAME,
          password: RMAB_ADMIN_PASSWORD,
        },
        audiobookshelf: {
          server_url: ABS_URL,
          api_token: absApiKey,
          library_id: absLibraryId,
          trigger_scan_after_import: true,
        },
        authMethod: "manual",
        registration: {
          require_admin_approval: true,
        },
        prowlarr: {
          url: PROWLARR_URL,
          api_key: PROWLARR_API_KEY,
          indexers: prowlarrIndexers,
        },
        downloadClient: [
          {
            id: "setup-sabnzbd",
            type: "sabnzbd",
            name: "SABnzbd",
            enabled: true,
            url: SABNZBD_URL,
            username: "",
            password: SABNZBD_API_KEY,
            disableSSLVerify: false,
            remotePathMappingEnabled: false,
            category: "readmeabook",
          },
        ],
        paths: {
          download_dir: DOWNLOAD_DIR,
          media_dir: MEDIA_DIR,
          metadata_tagging_enabled: true,
          chapter_merging_enabled: true,
        },
      };

      const complete = await request(`${RMAB_URL}/api/setup/complete`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      });
      ensureOk(complete, "ReadMeABook setup completion");
      if (!complete.json?.success) {
        throw new Error(`ReadMeABook setup response was not successful: ${JSON.stringify(complete.json)}`);
      }

      console.log("[bootstrap] ReadMeABook setup complete");
      console.log(`[bootstrap] ReadMeABook URL: ${RMAB_PUBLIC_URL}`);
    }

    async function main() {
      console.log("[bootstrap] Waiting for dependent services");

      await waitFor("Audiobookshelf", async () => {
        const result = await request(`${ABS_URL}/healthcheck`);
        return result.response.ok;
      });

      await waitFor("ReadMeABook", async () => {
        const result = await request(`${RMAB_URL}/api/health`);
        return result.response.ok;
      });

      await waitFor("Prowlarr", async () => {
        const result = await request(`${PROWLARR_URL}/api/v1/system/status`, {
          headers: {
            "X-Api-Key": PROWLARR_API_KEY,
          },
        });
        return result.response.ok;
      });

      await waitFor("SABnzbd", async () => {
        const result = await request(`${SABNZBD_URL}/api?mode=version&apikey=${encodeURIComponent(SABNZBD_API_KEY)}&output=json`);
        return result.response.ok && Boolean(result.json?.version);
      });

      await ensureAbsInitialized();
      const absSessionToken = await loginAbs();
      const absLibraryId = await ensureAbsLibrary(absSessionToken);
      const absApiKey = await createAbsApiKey(absSessionToken);
      const prowlarrIndexers = await getEnabledProwlarrIndexers();
      await bootstrapRmab(absApiKey, absLibraryId, prowlarrIndexers);

      console.log("[bootstrap] Completed successfully");
    }

    main().catch((error) => {
      const message = error instanceof Error ? error.stack || error.message : String(error);
      console.error(`[bootstrap] Failed: ${message}`);
      process.exit(1);
    });
